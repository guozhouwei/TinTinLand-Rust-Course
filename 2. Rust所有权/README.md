# TinTinLand-Rust-Course
TinTinLand Rust 课程笔记-Rust所有权

## 课件：
https://drive.google.com/file/d/1WvBBL6thFnqUbHoatjPFdinnL0v7RbLF/view

## 课堂笔记

#### 所有权
Rust明确了所有权的概念。值也可以叫资源。所有权就是对资源拥有的权利。Rust
基于所有权定义出发,推导了整个世界。所有权的基础是三条定义:

● Rust中,每一个值(资源)都有一个所有者;

● 任何一个时刻,一个值只有一个所有者;

● 当所有者所在作用域结束的时候,值会被释放掉。

三个规则,涉及两个概念,所有者,作用域。
所谓所有者,在代码中,就表示为变量。也就是说所有者会用变量名来表示。
变量的作用域,就是变量有效(valid)的那个区间。在Rust中,简单来说就是在一
对花括号括起的里面部分中,从变量创建时开始,到花括号结束的地方。比如:
```rust
fn main() {
    let s = String::from("hello");
    // do stuff with s
}
fn main() {
    let a = 1u32;
    {
        let s = String::from("hello");
    }
    // other stuff
}
```

#### RAII
这种堆内存资源随着关联的栈上局部变量一起被回收的内存管理特性,叫作 RAII
(Resource Acquisition Is Initialization)。它实际不是Rust的原创,是C++创造的。
学过C的同学可以对比一下C中的malloc()方式,C语言里面必须由程序员手动在后面
的代码中使用free()来释放堆内存资源,而RAII不需要手动写free()。可以看到RAII是
一个相当大的进步。

#### 移动还是复制
对于变量的绑定来说,哪些类型默认是做移动(所有权)操作,哪些基本
(primitive)类型默认是做复制(而产生新的资源及所有权)操作呢?
默认做复制操作的有:

● 所有的整数类型,比如u32,

● 布尔类型,bool

● 浮点数类型:f32, f64

● 字符类型 char

● 由以上类型组成的元组类型 Tuple,如(i32, i32, char)

其它类型,默认都是做值的移动操作。

#### 借用与引用
但是,正如,前面例子所说,如果要在调用完函数后,继续用这个变量,怎么办呢?
我们采取的办法就是把那个值返回回来——把所有权转移回来。
但是这样,相当麻烦。于是,Rust又引入了借用的概念。
借用概念是很自然的,也是跟现实的思维一致的。你有一样东西,别人想用一下,
可以从你这里借,你可以出借。那“引用”概念,又是什么呢?其实借用和引用是一
体两面,对同一个事情的两个面的描述。你把东西借给别人,也就是别人持有了对
你这个东西的引用。借用是站在资源拥有者角度来说的,引用是站在想借这个资源
的变量角度来说的。

在Rust中,引用具体就在变量前用“&”符号来表示,比如 &x。其实,引用也是一种
值,并且是固定长度的值（引用长度跟计算机体系架构相关，操作系统是64位那么引用就是64位（8个字节），操作系统是32位那么引用就是32位）。既然是值,当然可以赋给另一个变量。既然是固定长度
的值,那其实做的就是引用的复制copy操作。

##### 引用和c语言中指针的区别：
rust中引用是一定有效的，指向合法资源，而c中指针是随意指的，指向一个不合法地址也是可以的，
```rust
let b = &a;
let c = b; // 复制操作(引用复制操作)
```

```rust
fn main() {
    let s1 = String::from("I am a superman.");
    let s2 = &s1;
    let s3 = &&&&&s1;
    let s4 = &s2;
    let s5 = s2;
    println!("{s1}");
    println!("{s2}");
    println!("{s3}");
    println!("{s4}");
    println!("{s5}");
}
//
符合我们的期望。同样,这些引用,都没有导致堆中的字符串资源被复制一份或多
份。字符串的所有权仍然在s1那里,其它s2, s3, s4, s5都是对这个所有权的引用。

同时还可以看出,在Rust中,一个所有权型变量(上述示例中的s1)带有值和类型
的信息,一个引用型变量(上述示例中的s2, s3, s4, s5)也带有值和类型的信息,
不然它没法正确回溯到最终的值。这些信息是由Rust编译器内部维护的。
```

#### 不可变引用、可变引用
● 引用包含不可变引用和可变引用

● &x 对变量x的不可变引用

● &mut x 对变量x的可变引用

一个拥有所有权的变量的作用域是从它定义时到花括号结束。
而引用的作用域不是这样!引用的作用域是从它定义到它最后一次使用时结束!
如果它定义了,但并没有被使用,那它的作用域就只有它定义的那一行,即,出生即死亡。
同时,还存在一条规则: 一个资源的可变引用与不可变引用的作用域不能交叠(overlap)!也可以说不能同时存在。

引用(借用)的规则:

● 引用(不可变引用和可变引用都是)变量的作用域不会长于所有权变量的作用域。肯定的,不然就会出现悬锤引用了,这是典型的内存安全问题。Rust中的引用必定是有效的;

● 一个资源的可变引用与不可变引用的作用域不能交叠(overlap),也可以说不能同时存在;

● 某个时刻对某个资源只能存在一个可变引用,不能有超过一个可变引用同时存在;

● 一个资源的不可变引用,可以同时存在多个;

可变引用具有排他性

● 不可变引用可以被复制

● 可变引用不能被复制,只能被move



##### 例子分析
```rust
//不可变引用a与可变引用b有交集
#[test]
#[ignore]
fn test9() {
    let mut a = 10u32;
    let b = &mut a;
    *b = 20;

    println!("{a}"); TODO: immutable borrow occurs here
    println!("{b}");
}
```

```rust
//不可变引用c与可变引用b有交集
#[test]
#[ignore]
fn test11() {
    let mut a = 10u32;
    let b = &mut a;
    *b = 20;
    let c = &a;

    println!("{b}");
}
```

```rust
//不可变引用c与可变引用b有交集
#[test]
#[ignore]
fn test13() {
    let mut a = 10u32;
    let c = &a;
    let b = &mut a;
    *b = 20;

    println!("{c}");
}
```

```rust
//某个时刻对某个资源存在2个可变引用 b,d
#[test]
#[ignore]
fn test15() {
    let mut a = 10u32;
    let b = &mut a;
    *b = 20;
    let d = &mut a;
    
    println!("{b}");
}
```

```rust
\\可变引用不能复制，只能move
#[test]
#[ignore]
fn test16() {
    let mut a = 10u32;
    let r1 = &mut a;
    let r2 = r1;

    println!("{r1}");
}
```

```rust
//不可变引用具有排他性，是原始资源的唯一代理，不可变引用作用域期，所有权也不可用
#[test]
#[ignore]
fn test18() {
    let mut a = 10u32;
    let r1 = &mut a;
    let r2 = r1;

    println!("{a}");
    println!("{r2}");
}
```

